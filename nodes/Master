#!/usr/bin/env python

import math

# import of relevant libraries.
import rospy # module for ROS APIs
import tf
import random

# import msg/action/srv
from geometry_msgs.msg import Twist # message type for cmd_vel
from sensor_msgs.msg import LaserScan # message type for scan
from nav_msgs.msg import Odometry # message type for odom
from turtlesim.msg import Pose

from ppgapt.msg import Registration_msg
from ppgapt.msg import Kill_msg
from ppgapt.msg import Alive_msg
from ppgapt.msg import New_gen_msg
from ppgapt.msg import Ready_msg
from ppgapt.msg import Hunt_msg


LASER_ANGLE_FRONT = 0 # radians
MIN_THRESHOLD_DISTANCE = 0.5 # m, threshold distance.
# Constants
NUM_PREY_BOTS = 3 # Number of prey bots
NUM_PREDATOR_BOTS = 1 # Number of predator bots
KILLED_THRESHOLD = 2 # Once this many bots are killed, a new generation is spawned

MIN_LINEAR_VEL = 0.05 # m/s
MAX_LINEAR_VEL = 2.00 # m/s
MIN_ANGULAR_VEL = math.pi/8 # rad/s
MAX_ANGULAR_VEL = math.pi # rad/s


class Master():
    def __init__(self):

        self.num_prey_bots = NUM_PREY_BOTS
        self.num_predator_bots = NUM_PREDATOR_BOTS
        self.num_killed = 0
        self.num_killed_threshold = KILLED_THRESHOLD
        self.generation_count = 0
        self.first_gen_spawned = False

        self.ready = False
        self.num_ready = 0

        self.prey = set()
        self.alive = {}
        self.dead = []

        # Custom message publisher
        self._alive_pub = rospy.Publisher("/alive", Alive_msg, queue_size=1)
        self._new_gen_pub = rospy.Publisher("/new_gen", New_gen_msg, queue_size=1)
        self._hunt_pub = rospy.Publisher("/hunt", Hunt_msg, queue_size=1)

        # Set up subscribers
        # create service for registration
        self._registration_sub = rospy.Subscriber("/registration", Registration_msg, self.registration_callback)
        self._ready_sub = rospy.Subscriber("/ready", Ready_msg, self.ready_callback)

        # create kill message subscriber
        self._kill_sub = rospy.Subscriber("/kill", Kill_msg, self.kill_callback)


    # A function to spawn the first generation of predator and prey robots
    def spawn_first_gen(self):

        print("spawning first gen")

        for prey in self.prey:
            print("adding prey", prey)
            
            # Generate random velocities
            velocities = self.genetic_velocities()
            angular = velocities[0]
            linear = velocities[1]
            
            # Construct alive message
            alive = Alive_msg()
            alive.robot_name = prey
            alive.linear_vel = linear
            alive.angular_vel = angular


            # Update alive robot dictionary
            self.alive[prey] = (linear, angular)

            # Publish alive message
            self._alive_pub.publish(alive)


    # A function to spawn the next generation of prey robots
    def new_gen(self):
        
        self.num_ready = 0
        # Publish message to allocate predator/prey to waypoints
        new_gen = New_gen_msg()
        new_gen.new_gen = True
        self._new_gen_pub.publish(new_gen)

        print("entering infinite loop")
        while True:
            continue

        # While loop to ensure all bots are at their waypoints before next round starts
        while self.ready == False:
            rospy.sleep(2)

        # Reset number of ready bots
        self.ready = False



        # Tell predators to start hunting again
        hunt = Hunt_msg()
        self._hunt_pub.publish(hunt)



        # For each dead bot, generate new params and send alive message
        for dead_bot in self.dead:

            alive_bots = len(self.alive.keys())

            first = random.randint(0, alive_bots)
            second = random.randint(0, alive_bots)

            # Ensure two different parent bots
            while second == first:
                second = random.randint(0, alive_bots)

            # first_parent = list(self.alive.keys())[first]
            # second_parent = list(self.alive.keys())[second]

            first_parent = random.choice(list(self.alive.keys()))
            second_parent = random.choice(list(self.alive.keys()))

            new_linear = (self.alive[first_parent][0] + self.alive[second_parent][0]) / 2
            new_angular = (self.alive[first_parent][1] + self.alive[second_parent][1]) / 2

            # Construct alive message
            alive = Alive_msg()
            alive.robot_name = dead_bot
            alive.linear_vel = new_linear
            alive.angular_vel = new_angular

            # Update alive robot dictionary
            self.alive[dead_bot] = (new_linear, new_angular)

            # Publish alive message
            self._alive_pub.publish(alive)

            # Remove dead_bot from dead list
            self.dead.remove(dead_bot)

    

    # A function to randomly generate linked velocity traits 
    def genetic_velocities(self):

        speed_percentage = random.uniform(0.1, 1)
        speed = MIN_LINEAR_VEL + (speed_percentage * (MAX_LINEAR_VEL-MIN_LINEAR_VEL))

        angular_percentage = 1 - speed_percentage
        angular = MIN_ANGULAR_VEL + (angular_percentage * (MAX_ANGULAR_VEL-MIN_ANGULAR_VEL))

        return (angular, speed)



    # CALLBACK FUNCTIONS

    # Callback function which adds prey to prey list
    def registration_callback(self, msg):
        self.prey.add(msg.robotname.data)

        # Launch first generation once all prey bots are registered
        if len(self.prey) == self.num_prey_bots and self.first_gen_spawned == False:
            self.first_gen_spawned = True
            self.spawn_first_gen()


    # Callback function for when a robot is killed
    def kill_callback(self, msg):
        # Update lists
        killed_bot = msg.robot_name
        if killed_bot in self.alive:
            del self.alive[killed_bot]
            self.dead.append(killed_bot)
            self.num_killed += 1
            print("Kill occured")

        # If threshold met, start new generation
        if self.num_killed == self.num_killed_threshold:
            print("spawning new generation")
            self.new_gen()
            self.num_killed = 0

    # Callback function to ensure every robot has moved to its waypoint before next round
    def ready_callback(self, msg):

        self.num_ready += 1
        if self.num_ready == (self.num_prey_bots + self.num_predator_bots):
            self.ready = True
    


def main():
    """Main function."""

    # 1st. initialization of node.
    rospy.init_node("Master")
       
    # Initialize variables
    freq = 10


    # Sleep for a few seconds to wait for the registration.
    rospy.sleep(2)

    # Initialization of the class for the flocking motion.
    master = Master()

    # Sleep for a few seconds to wait for the registration.
    rospy.sleep(2)

    # # If interrupted, send a stop command.
    # rospy.on_shutdown(master.stop)

    # Update velocities
    # try:
    #     rate = rospy.Rate(freq)

    #     while not rospy.is_shutdown():
    #         rate.sleep()

    # except rospy.ROSInterruptException:
    #     rospy.logerr("ROS node interrupted.")

    rospy.spin()

if __name__ == "__main__":
    """Run the main function."""
    main()


        
