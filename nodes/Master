#!/usr/bin/env python

import math

# import of relevant libraries.
import rospy # module for ROS APIs
import tf
from random import random

# import msg/action/srv
from geometry_msgs.msg import Twist # message type for cmd_vel
from sensor_msgs.msg import LaserScan # message type for scan
from nav_msgs.msg import Odometry # message type for odom
from turtlesim.msg import Pose
from Prey import Prey

from ppgapt.msg import Registration
from ppgapt.msg import kill_msg
from ppgapt.msg import alive_msg
from ppgapt.msg import new_gen_msg
from ppgapt.msg import ready_msg


# Constants
NUM_PREY_BOTS = 10 # Number of prey bots
NUM_PREDATOR_BOTS = 2 # Number of predator bots
KILLED_THRESHOLD = 4 # Once 4 bots are killed, a new generation is spawned


class Master():
    def __init__(self):

        self.num_prey_bots = NUM_PREY_BOTS
        self.num_predator_bots = NUM_PREDATOR_BOTS
        self.num_killed = 0
        self.num_killed_threshold = KILLED_THRESHOLD
        self.generation_count = 0

        self.ready = False
        self.num_ready = 0

        self.prey = []
        self.alive = {}
        self.dead = []

        # Custom message publisher
        self._alive_pub = rospy.Publisher("alive", alive_msg, queue_size=1)
        self._new_gen_pub = rospy.Publisher("new_gen", new_gen_msg, queue_size=1)

        # Set up subscribers
        # create service for registration
        self._registration_sub = rospy.Subscriber("registration", Registration, self.registration_callback)
        self._ready_sub = rospy.Subscriber("ready", ready_msg, self.ready_callback)

        # create kill message subscriber
        self._kill_sub = rospy.Subscriber("kill", Kill, self.kill_callback)


    # A function to spawn the first generation of predator and prey robots
    def spawn_first_gen(self):

        for prey in self.prey:
            
            # Generate random velocities
            velocities = self.genetic_velocities()
            angular = velocities[0]
            linear = velocities[1]
            
            # Construct alive message
            alive = alive_msg()
            alive.robot_name.data = prey
            alive.linear_vel.data = linear
            alive.angular_vel.data = angular

            # Update alive robot dictionary
            self.alive[prey] = (linear, angular)

            # Publish alive message
            self._alive_pub.publish(alive)


    # A function to spawn the next generation of prey robots
    def new_gen(self):
        
        self.num_ready = 0
        # Publish message to allocate predator/prey to waypoints
        new_gen = new_gen_msg()
        new_gen.new_gen.data = True
        self._new_gen_pub.publish(new_gen)

        # While loop to ensure all bots are at their waypoints before next round starts
        while self.ready == False:
            rospy.sleep(2)

        # Reset number of ready bots
        self.ready = False

        alive_bots = len(self.alive)

        # For each dead bot, generate new params and send alive message
        for dead_bot in self.dead:
            first = random.randint(0, alive_bots)
            second = random.randint(0, alive_bots)

            # Ensure two different parent bots
            while second == first:
                second = random.randint(0, alive_bots)

            first_parent = list(self.alive_bots.keys())[first]
            second_parent = list(self.alive_bots.keys())[second]

            new_linear = (self.alive[first_parent][0] + self.alive[second_parent][0]) / 2
            new_angular = (self.alive[first_parent][1] + self.alive[second_parent][1]) / 2

            # Construct alive message
            alive = alive_msg()
            alive.robot_name.data = dead_bot
            alive.linear_vel.data = new_linear
            alive.angular_vel.data = new_angular

            # Update alive robot dictionary
            self.alive[dead_bot] = (linear, angular)

            # Publish alive message
            self._alive_pub.publish(alive)

            # Remove dead_bot from dead list
            self.dead.remove(dead_bot)

    

    # A function to randomly generate linked velocity traits 
    def genetic_velocities(self):

        speed_percentage = random.uniform(0, 1)
        speed = MIN_LINEAR_VEL + (speed_percentage * (MAX_LINEAR_VEL-MIN_LINEAR_VEL))

        angular_percentage = 1 - speed_percentage
        angular = MIN_ANGULAR_VEL + (angular_percentage * (MAX_ANGULAR_VEL-MIN_ANGULAR_VEL))

        return (angular, speed)



    # CALLBACK FUNCTIONS

    # Callback function which adds prey to prey list
    def registration_callback(self, msg):
        self.preys.append(msg.robotname.data)

        # Launch first generation once all prey bots are registered
        if len(self.preys) == self.num_prey_bots:
            self.spawn_first_gen()


    # Callback function for when a robot is killed
    def kill_callback(self, msg):
        # Update lists
        killed_bot = msg.robot_name.data
        del self.alive[killed_bot]
        self.dead.append(killed_bot)
        self.num_killed += 1

        # If threshold met, start new generation
        if self.num_killed == num_killed_threshold:
            self.new_gen()
            self.num_killed = 0

    # Callback function to ensure every robot has moved to its waypoint before next round
    def ready_callback(self, msg):

        self.num_ready += 1
        if self.num_ready == (self.num_prey_bots + self.num_predator_bots):
            self.ready = True
    


def main():
    """Main function."""

    # 1st. initialization of node.
    rospy.init_node("Master")
       
    # Initialize variables
    freq = 10


    # Sleep for a few seconds to wait for the registration.
    rospy.sleep(2)

    # Initialization of the class for the flocking motion.
    master = Master()

    # Sleep for a few seconds to wait for the registration.
    rospy.sleep(2)

    # If interrupted, send a stop command.
    rospy.on_shutdown(master.stop)

    # Update velocities
    try:
        rate = rospy.Rate(freq)

        while not rospy.is_shutdown():
            rate.sleep()

    except rospy.ROSInterruptException:
        rospy.logerr("ROS node interrupted.")

if __name__ == "__main__":
    """Run the main function."""
    main()


        
