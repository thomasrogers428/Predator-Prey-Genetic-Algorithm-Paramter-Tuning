#!/usr/bin/env python

import math

# import of relevant libraries.
import rospy # module for ROS APIs
import tf

# import msg/action/srv
from geometry_msgs.msg import Twist # message type for cmd_vel
from sensor_msgs.msg import LaserScan # message type for scan
from nav_msgs.msg import Odometry # message type for odom
from turtlesim.msg import Pose
from Prey import Prey

from ppgapt.msg import Registration
from ppgapt.msg import Alive_msg

LASER_ANGLE_FRONT = 0 # radians
MIN_THRESHOLD_DISTANCE = MIN_THRESHOLD_DISTANCE = 0.5 # m, threshold distance.
# Constants
FIRST_GEN_BOTS = 10 # Number of prey bots in the first generation
KILLED_THRESHOLD = 4 # Once 4 bots are killed, a new generation is spawned



class Master():
    def __init__(self):

        self.first_gen = FIRST_GEN_BOTS
        self.num_killed = 0
        self.num_killed_threshold = KILLED_THRESHOLD
        self.generation_count = 0

        self.preys = []
        self.spawn_first_gen()

        # Set up subscribers

        # create service for registration
        self._registration_sub = rospy.Subscriber("registration", Registration, self.registration_callback)

        # create kill message subscriber
        self._kill_sub = rospy.Subscriber("kill", Kill, self.kill_callback)


    # Callback function which adds prey to prey list
    def registration_callback(self, msg):
        self.preys.append(msg.robotname.data)


    # Callback function for when a robot is killed
    def kill_callback(self, msg):
        return


    # A function to spawn the first generation of robots
    def spawn_first_gen(self):

        for i in range(0, self.first_gen):
            name = "robot_" + str(i)
            # Generate random parameters 
            prey_x = Prey()

    
    


        # create service for registration
        self._registration_sub = rospy.Subscriber("registration", Registration, self.registration_callback)

        # create kill message subscriber
        self._kill_sub = rospy.Subscriber("kill", Kill, self.kill_callback)


    # Callback function which adds prey to prey list
    def registration_callback(self, msg):
        self.preys.append(msg.robotname.data)


    # Callback function for when a robot is killed
    def kill_callback(self, msg):
        return


    # A function to spawn the first generation of robots
    def spawn_first_gen(self):

        for i in range(0, self.first_gen):
            name = "robot_" + str(i)
            # Generate random parameters 
            prey_x = Prey()

    
    


    






    # A function to randomly generate linked traits 
    def genetic_velocities(self):

        speed_percentage = random.uniform(0, 1)
        speed = MIN_LINEAR_VEL + (speed_percentage * (MAX_LINEAR_VEL-MIN_LINEAR_VEL))

        angular_percentage = 1 - speed_percentage
        angular = MIN_ANGULAR_VEL + (angular_percentage * (MAX_ANGULAR_VEL-MIN_ANGULAR_VEL))

        return (angular, speed)
    

    # A function to randomly generate linked traits 
    def genetic_velocities(self):

        speed_percentage = random.uniform(0, 1)
        speed = MIN_LINEAR_VEL + (speed_percentage * (MAX_LINEAR_VEL-MIN_LINEAR_VEL))

        angular_percentage = 1 - speed_percentage
        angular = MIN_ANGULAR_VEL + (angular_percentage * (MAX_ANGULAR_VEL-MIN_ANGULAR_VEL))

        return (angular, speed)


    # Adapted from SimpleMotion class
    def _laser_callback(self, msg):
        """Processing of laser message."""
        # Access to the index of the measurement in front of the robot.
        # NOTE: assumption: the one at angle 0 corresponds to the front.
        i = int((LASER_ANGLE_FRONT - msg.angle_min) / msg.angle_increment)
        if msg.ranges[i] <= MIN_THRESHOLD_DISTANCE:
            self._close_obstacle = True
        else:
            self._close_obstacle = False
    

    # Rotate in place method adapted from simple_motion class
    def rotate_in_place(self, rotation_angle):
        """
        Rotate in place the robot of rotation_angle (rad) based on fixed velocity.
        Assumption: Counterclockwise rotation.
        """
        twist_msg = Twist()
        twist_msg.angular.z = self.angular_velocity
        
        duration = rotation_angle / twist_msg.angular.z
        start_time = rospy.get_rostime()
        rate = rospy.Rate(self.freq)
        while not rospy.is_shutdown():
            # Check if done
            if rospy.get_rostime() - start_time >= rospy.Duration(duration):
                break
                
            # Publish message.
            self._cmd_pub.publish(twist_msg)
            
            # Sleep to keep the set frequency.
            rate.sleep()

        # Rotated the required angle, stop.
        self.stop()


    # Move forward method adapted from simple_motion class
    def move_forward(self, distance):
        """Function to move_forward for a given distance."""
        # Rate at which to operate the while loop.
        rate = rospy.Rate(FREQUENCY)

        # Setting velocities. 
        twist_msg = Twist()
        twist_msg.linear.x = self.linear_velocity
        start_time = rospy.get_rostime()
        duration = rospy.Duration(distance/twist_msg.linear.x)

        # Loop.
        while not rospy.is_shutdown():
            # Check if traveled of given distance based on time.
            if rospy.get_rostime() - start_time >= duration:
                break

            # Publish message.
            if self._close_obstacle:
                self.stop()
            else:
                self._cmd_pub.publish(twist_msg)

            # Sleep to keep the set publishing frequency.
            rate.sleep()

        # Traveled the required distance, stop.
        self.stop()
        
    def _laser_callback(self, msg):
        """Processing of laser message."""
        # Access to the index of the measurement in front of the robot.
        # NOTE: assumption: the one at angle 0 corresponds to the front.
        i = int((LASER_ANGLE_FRONT - msg.angle_min) / msg.angle_increment)
        if msg.ranges[i] <= MIN_THRESHOLD_DISTANCE:
            self._close_obstacle = True
        else:
            self._close_obstacle = False


    def stop(self):
        """Stop the robot."""
        twist_msg = Twist()
        self._cmd_pub.publish(twist_msg)



def main():
    """Main function."""

    # 1st. initialization of node.
    rospy.init_node("Master")
       
    # Initialize variables
    freq = 10


    # Sleep for a few seconds to wait for the registration.
    rospy.sleep(2)

    # Initialization of the class for the flocking motion.
    master = Master()

    # Sleep for a few seconds to wait for the registration.
    rospy.sleep(2)

    # If interrupted, send a stop command.
    rospy.on_shutdown(master.stop)

    # Update velocities
    try:
        rate = rospy.Rate(freq)

        while not rospy.is_shutdown():
            rate.sleep()

    except rospy.ROSInterruptException:
        rospy.logerr("ROS node interrupted.")

if __name__ == "__main__":
    """Run the main function."""
    main()


        
