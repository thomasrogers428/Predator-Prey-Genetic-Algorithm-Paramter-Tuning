#!/usr/bin/env python

import math

# import of relevant libraries.
import rospy # module for ROS APIs
import tf
import random

# import msg/action/srv
from geometry_msgs.msg import Twist # message type for cmd_vel
from sensor_msgs.msg import LaserScan # message type for scan
from nav_msgs.msg import Odometry # message type for odom
from turtlesim.msg import Pose

from ppgapt.msg import Registration_msg
from ppgapt.msg import Alive_msg
from ppgapt.msg import Kill_msg

from SimpleMotion import *


LASER_ANGLE_FRONT = 0 # radians
MIN_THRESHOLD_DISTANCE = MIN_THRESHOLD_DISTANCE = 0.5 # m, threshold distance.


# Constants
FREQUENCY = 10 #Hz.
LASER_ANGLE_FRONT = 0 # radians
LINEAR_VELOCITY = 0.2 # m/s
ANGULAR_VELOCITY = math.pi/4 # rad/s
MIN_THRESHOLD_DISTANCE = 0.8 # m, threshold distance.

MIN_LINEAR_VEL = 0.05 # m/s
MAX_LINEAR_VEL = 2.00 # m/s
MIN_ANGULAR_VEL = math.pi/8 # rad/s
MAX_ANGULAR_VEL = math.pi # rad/s

DEFAULT_ODOM_TOPIC = 'odom'
DEFAULT_CMD_VEL_TOPIC = "cmd_vel"
DEFAULT_REGISTRATION_TOPIC = "registration"
DEFAULT_LASER_TOPIC = 'base_scan'
DEFAULT_ALIVE_TOPIC = 'alive'
CUSTOM_KILL_TOPIC = 'kill'



class Prey():
    def __init__(self):

        # velocities = self.genetic_velocities()
        self.angular_velocity = 0
        self.linear_velocity = 0
        self.namespace = rospy.get_namespace()
        self._close_obstacle = None

        self.start_x, self.start_y = rospy.get_param(self.namespace[:-1] + "_x"), rospy.get_param(self.namespace[:-1] + "_y")

        self.is_alive = True
        self.odom_dict = {}

        # Set up publishers
        cmd_vel_topic = self.namespace + DEFAULT_CMD_VEL_TOPIC
        self._cmd_pub = rospy.Publisher(cmd_vel_topic, Twist, queue_size=1)
        
        
        odom_topic = self.namespace + DEFAULT_ODOM_TOPIC
        self._odom_pub_ = rospy.Publisher(odom_topic, Pose, queue_size=1)

        # Register prey robot with predators
        self._registration_pub = rospy.Publisher(DEFAULT_REGISTRATION_TOPIC, Registration_msg, queue_size=1)
        registration_msg = Registration_msg()
        registration_msg.robotname = self.namespace
        self._registration_pub.publish(registration_msg)
        
        # Set up subscribers
        self._laser_sub = rospy.Subscriber(DEFAULT_LASER_TOPIC, LaserScan, self._laser_callback, queue_size=1)
        self._is_alive_sub = rospy.Subscriber(DEFAULT_ALIVE_TOPIC, Alive_msg, self._is_alive_callback, queue_size=1)
        self._odom_sub = rospy.Subscriber(odom_topic, Odometry, self._odom_callback, queue_size=1)
        self._kill_sub = rospy.Subscriber(CUSTOM_KILL_TOPIC, Kill_msg, self._kill_callback, queue_size=1)

    # method to avoid predators using separation
    def evade(self):

        rotate_in_place(random.uniform(0, 2*math.pi), self._cmd_pub, self.angular_velocity)
        move_forward(random.uniform(1, 3), self._cmd_pub, self.linear_velocity)
        
    def _is_alive_callback(self, msg):
        self.is_alive = True
        self.linear_velocity = msg.linear_vel
        self.angular_velocity = msg.angular_vel

    def _odom_callback(self, msg):
        return
    
    def _kill_callback(self, msg):
        self.is_alive = False
        self.angular_velocity = 0
        self.linear_velocity = 0

    def _laser_callback(self, msg):
        i = int((LASER_ANGLE_FRONT - msg.angle_min) / msg.angle_increment)
        if msg.ranges[i] <= MIN_THRESHOLD_DISTANCE:
            self._close_obstacle = True
        else:
            self._close_obstacle = False


    # A function to randomly generate linked traits 
    # def genetic_velocities(self):

    #     speed_percentage = random.uniform(0, 1)
    #     speed = MIN_LINEAR_VEL + (speed_percentage * (MAX_LINEAR_VEL-MIN_LINEAR_VEL))

    #     angular_percentage = 1 - speed_percentage
    #     angular = MIN_ANGULAR_VEL + (angular_percentage * (MAX_ANGULAR_VEL-MIN_ANGULAR_VEL))

    #     return (angular, speed)



def main():
    """Main function."""

    # 1st. initialization of node.
    rospy.init_node("Prey")
       
    # Initialize variables
    freq = 10


    # Sleep for a few seconds to wait for the registration.
    rospy.sleep(2)

    # Initialization of the class for the flocking motion.
    prey = Prey()

    # Sleep for a few seconds to wait for the registration.
    rospy.sleep(2)

    # # If interrupted, send a stop command.
    # rospy.on_shutdown(stop(prey._cmd_pub))

    # Update velocities
    try:
        rate = rospy.Rate(freq)

        while not rospy.is_shutdown():
            prey.evade()
            rate.sleep()

    except rospy.ROSInterruptException:
        rospy.logerr("ROS node interrupted.")

if __name__ == "__main__":
    """Run the main function."""
    main()
